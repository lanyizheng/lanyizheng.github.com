#线性时间排序

我们所熟知的排序算法（插入排序，堆排序，快速排序），都是“比较排序”，这是因为各元素的次序依赖于它们之间的比较。

这个部分将介绍三种线性时间复杂度的排序算法：计数排序、基数排序和桶排序，这些算法是用运算而不是比较来确定排序顺序的。

##1.计数排序
计数排序是计算数组中相同元素的个数，然后将这些元素放到合适的位置的一种算法，可以达到O(n)的时间复杂度，当然这样的算法是有局限的：它要求输入的元素必须在0-k之间，且元素必须是整数，而且k=O(n)的规模。

**假设**：n个输入元素中的每一个元素都是在0到k之间的一个整数，其中k为某个整数，当k=O(n)时，排序的运行时间为O(n)。

在具体的伪代码中，我们假设的输入时一个数组`A[1...n],A.length=n`。我们还需要两个数组：B[1...n]存放排序的输出，C[0...k]提供临时的存储空间。

**它是一种稳定排序。**

下面是COUNTING-SORT(A,B,k)

```
#初始化C[0...k],其中k是数组A中的最大元素
for i = 0 to k
	c[i]=0
#C的索引代表A中具体的元素，而索引所对应的值就是A中该元素的个数。
#比如C[3]=3，表示在数组A中有3个3的元素。
for j= 1 to A.length
	c[A[j]]=C[A[j]]+1
#修改C中元素，使得C[i]代表不大于i的元素的个数
#C[3]=4,表示在A中不大于3的元素有4个
for i= 1 to k
	C[i]=C[i]+C[i-1]

#将元素放在数组B中合适的位置
for j = A.length downto 1
	#A[j]应当在不大于A[j]的个数所代表的索引处
	#比如C[A[2]]=3,A[2]=3,表示A中不大于2的元素有3个，那么在数组B中，2应
	#放在索引3的地方
	B[C[A[j]]]=A[j]
	#防止A[j]元素有多个的情况,比如2有2个，刚刚放置的2,当重新放置一个新的2时需要将索引往前移动一位
	C[A[j]]=C[A[j]]-1
```

##2.基数排序
基数排序（radix sort）是用在卡片排序机上的算法。

基数排序是按照**最低有效位**来进行排序的。

下面的这个例子就能够很好的说明基数排序：

```
329		720		720		329
457		436		329		436
839 --->457 --->436 --->457
436		329		839		720
720		839		457		839
#先进行个位排序，再在此基础上进行十位排序，最后进行百位排序
```

下面是具体的伪代码 RADIX-SORT(A,d)：

```
for i = 1 to d
	use s stable sort to sort array A on digit i
```

利用**计数排序**作为中间**稳定排序**的基数排序不是原址排序，虽然基数排序的运行时间为O(n)，与快速排序的`O(nlg(n))`相比似乎时间代价更好，但是它的常数项因子并不是相同的，所以不能说明它的时间代价相比快速排序更好。

##3.桶排序
桶排序（bucket sort）假设输入数据服从均匀分布，平均情况下它的时间代价为O(n),它与计数排序类似，因为对输入数据做了某种假设，桶排序的速度很快。

在桶排序的代码中，我们假设输入是一个包含n个元素的数组A,且每一个元素A[i]满足$0\leqslant A[i] < 1$，还需要一个临时数组B[0...n]来存放链表（即桶）。

下面是BUCKET-SORT(A)的伪代码：

```
n=A.length
#初始化B[0...n]
for i = 0 to n-1
	make B[i] an empty list
for i = 1 to n
	insert A[i] into list B[|nA[i]|]
for i = 0 to n-1
	sort list B[i] with insertion sort 
cancatenate the list B[0],B[1],...,B[n-1] together in order
```

桶排序的期望运行时间是O(n),即使数据不服从均匀分布，桶排序也可以线性时间内完成，只要输入数据满足下列性质：**所有桶大小的平方和与总的元素程线性关系**，那么桶排序就可以在线性时间内完成。
